{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Scrubbr \u00b6 Serializing data in node shouldn't be hard. You shouldn't have to worry about accidentally leaking private information through your APIs. If you're using TypeScript, you already have everythign you need to effortlessly serialize and transform your data. Scrubbr transforms your TypeScript into a JSON schema and uses that to format your data. Install \u00b6 npm i -S scrubbr Quick Start \u00b6 The simplest example is to filter out sensitive data. In this example we want to filter the email and password out of this sample data: { users: [ { name: 'John Doe', image: 'http://i.pravatar.cc/300', email: 'donotspam@me.com', password: 'xxxsecretxxx', }, ], }; 1. Define your TypeScript schema \u00b6 First define a TypeScript schema file that only contains the properties you want in our output. // schema.ts type UserList = { users: User[]; }; type User = { name: string; image: string; }; 2. Serialize with Scrubbr \u00b6 Now initialize Scrubbr with a path to the schema file and serialize the data. import Scrubbr from 'scrubbr'; // PERFORMANCE NOTE: this is a synchronous call! // Load early and cache to a shared variable. const scrubbr = new Scrubbr('./schema.ts'); function api() { const data = getUsers(); // Serialize the data based on the UserList type defined in schema.ts return scrubbr.serialize('UserList', data); } 3. Ouput \u00b6 { \"users\": [ { \"name\": \"John Doe\", \"image\": \"http://i.pravatar.cc/300\" } ] } 4. Try it yourself \u00b6 You can play with an more complex example yourself by modifying the files in ./example and then running: npm run example Next up \u00b6 Follow along for more advanced features. Custom Serializers Tips & Tricks Troubleshooting API Docs","title":"Quick Start"},{"location":"#scrubbr","text":"Serializing data in node shouldn't be hard. You shouldn't have to worry about accidentally leaking private information through your APIs. If you're using TypeScript, you already have everythign you need to effortlessly serialize and transform your data. Scrubbr transforms your TypeScript into a JSON schema and uses that to format your data.","title":"Scrubbr"},{"location":"#install","text":"npm i -S scrubbr","title":"Install"},{"location":"#quick-start","text":"The simplest example is to filter out sensitive data. In this example we want to filter the email and password out of this sample data: { users: [ { name: 'John Doe', image: 'http://i.pravatar.cc/300', email: 'donotspam@me.com', password: 'xxxsecretxxx', }, ], };","title":"Quick Start"},{"location":"#1-define-your-typescript-schema","text":"First define a TypeScript schema file that only contains the properties you want in our output. // schema.ts type UserList = { users: User[]; }; type User = { name: string; image: string; };","title":"1. Define your TypeScript schema"},{"location":"#2-serialize-with-scrubbr","text":"Now initialize Scrubbr with a path to the schema file and serialize the data. import Scrubbr from 'scrubbr'; // PERFORMANCE NOTE: this is a synchronous call! // Load early and cache to a shared variable. const scrubbr = new Scrubbr('./schema.ts'); function api() { const data = getUsers(); // Serialize the data based on the UserList type defined in schema.ts return scrubbr.serialize('UserList', data); }","title":"2. Serialize with Scrubbr"},{"location":"#3-ouput","text":"{ \"users\": [ { \"name\": \"John Doe\", \"image\": \"http://i.pravatar.cc/300\" } ] }","title":"3. Ouput"},{"location":"#4-try-it-yourself","text":"You can play with an more complex example yourself by modifying the files in ./example and then running: npm run example","title":"4. Try it yourself"},{"location":"#next-up","text":"Follow along for more advanced features. Custom Serializers Tips & Tricks Troubleshooting API Docs","title":"Next up"},{"location":"serializers/","text":"Custom Serializers \u00b6 Custom serializers give you the power to transform data and influence Scrubbr. Type Serializers \u00b6 The most common serializer is the Type Serializer. This function is called whenever Scrubbr encounters a specific TypeScript type anywhere in the data. scrubbr.addTypeSerializer('User', (data, state) => { // Do custom things here for User typed data return data; }); Context \u00b6 You can pass a custom object to the serialize function, and it will be passed to your serializers inside the state param. For example, it could be the ID of the logged-in user: const context = { userId: 5, }; scrubbr.addTypeSerializer('User', serializeUser); const serialized = scrubbr.serialize('MemberList', data, context); // Only return the logged-in user function serializeUser(data, state) { const { context } = state; if (data.id !== context.userId) { return null; } return data; } Global Context \u00b6 You can also set the context globally and it will be merged with the context passed into the serialize function. For example: function userLoggedIn(user) { scrubbr.setGlobalContext({ loggedInUserId: user.id }); } function api() { const context = { timezone: 'America/Los_Angeles', }; const serialized = scrubbr.serialize('MemberList', data, context); } In this example, the context passed to serializers will potentially include both timezone and loggedInUserId , if the userLoggedIn function were called. Change Types \u00b6 Your serializer can tell Scrubbr to use a different type for serialization with the useType function. For example, maybe we want to use the limited PublicUser type for all User objects that are not the logged-in user: type User = { id: number; name: string; email: string; password: string; }; type PublicUser = { id: number; name: string; }; import Scrubbr, { useType } from '../src/'; const context = { userId: 5, }; scrubbr.addTypeSerializer('User', serializeUser); const serialized = scrubbr.serialize('MemberList', data, context); // Convert User to PublicUser for everyone but the logged-in user function serializeUser(data, state) { const { context } = state; if (data.id !== context.userId) { return useType('PublicUser'); } return data; } Generic Serializers \u00b6 Generic serializers are called for every node in the object being serialized. Be aware that this can slow down the overall serialization process. scrubbr.addGenericSerializer((data, state) => { // Transform the data here return data; }); Inside the serializer you'll often uses the following state properties to determine where you are: state.path - The object path to where you are (i.e. blog.posts[1].author.name ) state.name - The name of the property that is being serialized. state.index - If the node being serialized is an item in an array, this is the index in that array. Note In most cases Type Serializers provide a cleaner and more elegant way to serialize your data than Generic Serializers. Let's say we want to convert every startTime date value to the local timezone. type Event = { name: string; startTime: Date; }; type Meeting = { name: string; startTime: string; recurring: string; }; type AppointmentList = { events: Event[]; meeting: Meeting[]; }; import moment from 'moment-timezone'; import Scrubbr, { ScrubbrState } from 'scrubbr'; const scrubbr = new Scrubbr('./schema.ts'); function serializeStartTime(data: any, state: ScrubbrState) { const { name } = state; const { timezone } = state.context; if (name == 'startTime') { return moment(data).tz(timezone).format(); } return data; } function api() { const data = getData(); const context = { timezone: 'America/Los_Angeles', }; scrubbr.addGenericSerializer(serializeStartTime); const serialized = scrubbr.serialize('AppointmentList', data, context); } function getData() { return { events: [ { name: 'Pool party', startTime: '2021-06-26T19:00:00.000Z', }, ], meeting: [ { name: 'Daily standup', startTime: '2021-06-25T17:00:00.000Z', recurring: 'daily', }, ], }; } Alternate Example \u00b6 But let's see a more elegant way to handle the previous example. Instead of using the crude generic serializer, you can apply a consistent type to startTime and use a type serializer. type StartTime = Date; type Event = { name: string; startTime: StartTime; }; type Meeting = { name: string; startTime: StartTime; }; type AppointmentList = { events: Event[]; meeting: Meeting[]; recurring: string; }; import moment from 'moment-timezone'; import Scrubbr, { ScrubbrState } from 'scrubbr'; const scrubbr = new Scrubbr('./schema.ts'); function serializeStartTime(data: any, state: ScrubbrState) { const { name } = state; const { timezone } = state.context; return moment(data).tz(timezone).format(); } function api() { const data = getData(); const context = { timezone: 'America/Los_Angeles', }; scrubbr.addTypeSerializer('StartTime', serializeStartTime); const serialized = scrubbr.serialize('AppointmentList', data, context); } function getData() { return { events: [ { name: 'Pool party', startTime: '2021-06-26T19:00:00.000Z', }, ], meeting: [ { name: 'Daily standup', startTime: '2021-06-25T17:00:00.000Z', recurring: 'daily', }, ], }; }","title":"Custom Serializers"},{"location":"serializers/#custom-serializers","text":"Custom serializers give you the power to transform data and influence Scrubbr.","title":"Custom Serializers"},{"location":"serializers/#type-serializers","text":"The most common serializer is the Type Serializer. This function is called whenever Scrubbr encounters a specific TypeScript type anywhere in the data. scrubbr.addTypeSerializer('User', (data, state) => { // Do custom things here for User typed data return data; });","title":"Type Serializers"},{"location":"serializers/#context","text":"You can pass a custom object to the serialize function, and it will be passed to your serializers inside the state param. For example, it could be the ID of the logged-in user: const context = { userId: 5, }; scrubbr.addTypeSerializer('User', serializeUser); const serialized = scrubbr.serialize('MemberList', data, context); // Only return the logged-in user function serializeUser(data, state) { const { context } = state; if (data.id !== context.userId) { return null; } return data; }","title":"Context"},{"location":"serializers/#global-context","text":"You can also set the context globally and it will be merged with the context passed into the serialize function. For example: function userLoggedIn(user) { scrubbr.setGlobalContext({ loggedInUserId: user.id }); } function api() { const context = { timezone: 'America/Los_Angeles', }; const serialized = scrubbr.serialize('MemberList', data, context); } In this example, the context passed to serializers will potentially include both timezone and loggedInUserId , if the userLoggedIn function were called.","title":"Global Context"},{"location":"serializers/#change-types","text":"Your serializer can tell Scrubbr to use a different type for serialization with the useType function. For example, maybe we want to use the limited PublicUser type for all User objects that are not the logged-in user: type User = { id: number; name: string; email: string; password: string; }; type PublicUser = { id: number; name: string; }; import Scrubbr, { useType } from '../src/'; const context = { userId: 5, }; scrubbr.addTypeSerializer('User', serializeUser); const serialized = scrubbr.serialize('MemberList', data, context); // Convert User to PublicUser for everyone but the logged-in user function serializeUser(data, state) { const { context } = state; if (data.id !== context.userId) { return useType('PublicUser'); } return data; }","title":"Change Types"},{"location":"serializers/#generic-serializers","text":"Generic serializers are called for every node in the object being serialized. Be aware that this can slow down the overall serialization process. scrubbr.addGenericSerializer((data, state) => { // Transform the data here return data; }); Inside the serializer you'll often uses the following state properties to determine where you are: state.path - The object path to where you are (i.e. blog.posts[1].author.name ) state.name - The name of the property that is being serialized. state.index - If the node being serialized is an item in an array, this is the index in that array. Note In most cases Type Serializers provide a cleaner and more elegant way to serialize your data than Generic Serializers. Let's say we want to convert every startTime date value to the local timezone. type Event = { name: string; startTime: Date; }; type Meeting = { name: string; startTime: string; recurring: string; }; type AppointmentList = { events: Event[]; meeting: Meeting[]; }; import moment from 'moment-timezone'; import Scrubbr, { ScrubbrState } from 'scrubbr'; const scrubbr = new Scrubbr('./schema.ts'); function serializeStartTime(data: any, state: ScrubbrState) { const { name } = state; const { timezone } = state.context; if (name == 'startTime') { return moment(data).tz(timezone).format(); } return data; } function api() { const data = getData(); const context = { timezone: 'America/Los_Angeles', }; scrubbr.addGenericSerializer(serializeStartTime); const serialized = scrubbr.serialize('AppointmentList', data, context); } function getData() { return { events: [ { name: 'Pool party', startTime: '2021-06-26T19:00:00.000Z', }, ], meeting: [ { name: 'Daily standup', startTime: '2021-06-25T17:00:00.000Z', recurring: 'daily', }, ], }; }","title":"Generic Serializers"},{"location":"serializers/#alternate-example","text":"But let's see a more elegant way to handle the previous example. Instead of using the crude generic serializer, you can apply a consistent type to startTime and use a type serializer. type StartTime = Date; type Event = { name: string; startTime: StartTime; }; type Meeting = { name: string; startTime: StartTime; }; type AppointmentList = { events: Event[]; meeting: Meeting[]; recurring: string; }; import moment from 'moment-timezone'; import Scrubbr, { ScrubbrState } from 'scrubbr'; const scrubbr = new Scrubbr('./schema.ts'); function serializeStartTime(data: any, state: ScrubbrState) { const { name } = state; const { timezone } = state.context; return moment(data).tz(timezone).format(); } function api() { const data = getData(); const context = { timezone: 'America/Los_Angeles', }; scrubbr.addTypeSerializer('StartTime', serializeStartTime); const serialized = scrubbr.serialize('AppointmentList', data, context); } function getData() { return { events: [ { name: 'Pool party', startTime: '2021-06-26T19:00:00.000Z', }, ], meeting: [ { name: 'Daily standup', startTime: '2021-06-25T17:00:00.000Z', recurring: 'daily', }, ], }; }","title":"Alternate Example"},{"location":"tips/","text":"Tips & Tricks \u00b6 TypeScript Typing \u00b6 If you want to cast the serialized data to the type you serialized it to, just use the angle brackets: import { UserList } from 'schema'; const results = scrubbr.serialize<UserList>('UserList', data); Improving startup performance \u00b6 Converting the TypeScript to JSON can take a few moments. If you want to optimize startup time, you can save the schema to disk as part of your build step and then pass it directly to Scrubbr. Internally, Scrubbr uses the ts-json-schema-generator library to convert TypeScript to JSON schema. Warning You cannot load just any JSON schema into scrubbr, it needs to follow the output conventions of ts-json-schema-generator : * All types are defined in the root `definitions` object. * All references (`$ref`) point to definitions within the object. (i.e. no external references) Build Step \u00b6 This will build your schema file ( schema.ts ) and output it to dist/schema.json . npx ts-json-schema-generator -f ./tsconfig.json -e all -p ./schema.ts -o ./dist/schema.json Runtime code \u00b6 import Scrubbr, { JSONSchemaDefinitions } from 'scrubbr'; // Set `resolveJsonModule: true` in your tsconfig, otherwise use require() import * as schema from './schema.json'; const scrubbr = new Scrubbr(schema as JSONSchemaDefinitions); Clone the scrubbr serializer \u00b6 For performance reasons you might not want all the custom serializers for your entire app running on every object serialized. You also probably don't want to manually add the global serializers every time. You can use clone() to create API-specific scrubbrs off the global version. The TypeScript schema, scrubbr options, and custome serializers will be included in the cloned version. In this example we want the userSerializer used all data serialized and the commentSerializer only applied to the comment list API: // Global config const scrubbr = new Scrubbr('./schema.ts'); scrubbr.addTypeSerializer('User', userSerializer); // API endpoint function commentListApi() { const commentScrubbr = scrubbr.clone(); commentScrubbr.addTypeSerializer('Comment', commentSerializer); return scrubbr.serialize('CommentList', data); } Schema Validation \u00b6 For the sake of performance and simplicity, scrubber does not perform a schema validation. However, you can easily use ajv to validate the serialized object. import Ajv from 'ajv'; import Scrubbr from 'scrubbr'; const scrubbr = new Scrubbr('./schema.ts'); async function main() { // Serialize const output = scrubbr.serialize('UserList', data); const jsonSchema = scrubbr.getSchemaFor('UserList'); // Validate const ajv = new Ajv(); const schemaValidator = ajv.compile(jsonSchema); const isValid = schemaValidator(output); if (!isValid) { console.error(schemaValidator.errors); } }","title":"Tips & Tricks"},{"location":"tips/#tips-tricks","text":"","title":"Tips &amp; Tricks"},{"location":"tips/#typescript-typing","text":"If you want to cast the serialized data to the type you serialized it to, just use the angle brackets: import { UserList } from 'schema'; const results = scrubbr.serialize<UserList>('UserList', data);","title":"TypeScript Typing"},{"location":"tips/#improving-startup-performance","text":"Converting the TypeScript to JSON can take a few moments. If you want to optimize startup time, you can save the schema to disk as part of your build step and then pass it directly to Scrubbr. Internally, Scrubbr uses the ts-json-schema-generator library to convert TypeScript to JSON schema. Warning You cannot load just any JSON schema into scrubbr, it needs to follow the output conventions of ts-json-schema-generator : * All types are defined in the root `definitions` object. * All references (`$ref`) point to definitions within the object. (i.e. no external references)","title":"Improving startup performance"},{"location":"tips/#build-step","text":"This will build your schema file ( schema.ts ) and output it to dist/schema.json . npx ts-json-schema-generator -f ./tsconfig.json -e all -p ./schema.ts -o ./dist/schema.json","title":"Build Step"},{"location":"tips/#runtime-code","text":"import Scrubbr, { JSONSchemaDefinitions } from 'scrubbr'; // Set `resolveJsonModule: true` in your tsconfig, otherwise use require() import * as schema from './schema.json'; const scrubbr = new Scrubbr(schema as JSONSchemaDefinitions);","title":"Runtime code"},{"location":"tips/#clone-the-scrubbr-serializer","text":"For performance reasons you might not want all the custom serializers for your entire app running on every object serialized. You also probably don't want to manually add the global serializers every time. You can use clone() to create API-specific scrubbrs off the global version. The TypeScript schema, scrubbr options, and custome serializers will be included in the cloned version. In this example we want the userSerializer used all data serialized and the commentSerializer only applied to the comment list API: // Global config const scrubbr = new Scrubbr('./schema.ts'); scrubbr.addTypeSerializer('User', userSerializer); // API endpoint function commentListApi() { const commentScrubbr = scrubbr.clone(); commentScrubbr.addTypeSerializer('Comment', commentSerializer); return scrubbr.serialize('CommentList', data); }","title":"Clone the scrubbr serializer"},{"location":"tips/#schema-validation","text":"For the sake of performance and simplicity, scrubber does not perform a schema validation. However, you can easily use ajv to validate the serialized object. import Ajv from 'ajv'; import Scrubbr from 'scrubbr'; const scrubbr = new Scrubbr('./schema.ts'); async function main() { // Serialize const output = scrubbr.serialize('UserList', data); const jsonSchema = scrubbr.getSchemaFor('UserList'); // Validate const ajv = new Ajv(); const schemaValidator = ajv.compile(jsonSchema); const isValid = schemaValidator(output); if (!isValid) { console.error(schemaValidator.errors); } }","title":"Schema Validation"},{"location":"troubleshooting/","text":"Troubleshooting \u00b6 Look at the generated schema \u00b6 If scrubbr is not returning the data you're expecting, the first place to look is at the internal schema definitions: console.log(scrubbr.getSchema()); This is the JSON schema that was created from your TypeScript file. Next look at the schema definition for the type you're trying to serialize to. console.log(scrubbr.getSchemaFor('UserList')); Verify that this returns a JSON schema object and that it contains the properties you want serialized. Debug output \u00b6 To enable debug logging: import Scrubbr, { LogLevel } from 'scrubbr'; const scrubbr = new Scrubbr('./schema.ts', { logLevel: LogLevel.DEBUG }); Scrubbr can also nest the logs to make it easier to read: const scrubbr = new Scrubbr('./schema.ts', { logLevel: LogLevel.DEBUG, logNesting: true, // or enter a string if you want to use a custom indention }); Understanding the warning: \"Guessing: Using type 'xyz', instead of 'abc' , because it has the fewest properties\" \u00b6 Guessing: Using type 'UserPublic', instead of 'UserRestricted', because it has the fewest properties at object path: 'user'. (You can explicitly override this selection with the 'useType()' function in a custom serializer). This warning happens when you have a type like this: type Payload = { user: UserPublic | UserRestricted; }; When Scrubbr gets to the user property, it doesn't know exactly how to choose between UserPublic and UserRestricted and so it makes a guess and chooses the type that defines the fewest properties (most restrictive). In the interest of performance, Scrubbr avoids doing deep introspection and type checking. To avoid this warning, use a type alias return the useType function in a serializer: type Payload = { user: User; }; type User = UserPublic | UserRestricted; scrubbr.addTypeSerializer('User', (data, state) => { if (/* type choosing logic here */) { return useType('UserRestricted'); } return useType('UserPublic'); }","title":"Troubleshooting"},{"location":"troubleshooting/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"troubleshooting/#look-at-the-generated-schema","text":"If scrubbr is not returning the data you're expecting, the first place to look is at the internal schema definitions: console.log(scrubbr.getSchema()); This is the JSON schema that was created from your TypeScript file. Next look at the schema definition for the type you're trying to serialize to. console.log(scrubbr.getSchemaFor('UserList')); Verify that this returns a JSON schema object and that it contains the properties you want serialized.","title":"Look at the generated schema"},{"location":"troubleshooting/#debug-output","text":"To enable debug logging: import Scrubbr, { LogLevel } from 'scrubbr'; const scrubbr = new Scrubbr('./schema.ts', { logLevel: LogLevel.DEBUG }); Scrubbr can also nest the logs to make it easier to read: const scrubbr = new Scrubbr('./schema.ts', { logLevel: LogLevel.DEBUG, logNesting: true, // or enter a string if you want to use a custom indention });","title":"Debug output"},{"location":"troubleshooting/#understanding-the-warning-guessing-using-type-xyz-instead-of-abc-because-it-has-the-fewest-properties","text":"Guessing: Using type 'UserPublic', instead of 'UserRestricted', because it has the fewest properties at object path: 'user'. (You can explicitly override this selection with the 'useType()' function in a custom serializer). This warning happens when you have a type like this: type Payload = { user: UserPublic | UserRestricted; }; When Scrubbr gets to the user property, it doesn't know exactly how to choose between UserPublic and UserRestricted and so it makes a guess and chooses the type that defines the fewest properties (most restrictive). In the interest of performance, Scrubbr avoids doing deep introspection and type checking. To avoid this warning, use a type alias return the useType function in a serializer: type Payload = { user: User; }; type User = UserPublic | UserRestricted; scrubbr.addTypeSerializer('User', (data, state) => { if (/* type choosing logic here */) { return useType('UserRestricted'); } return useType('UserPublic'); }","title":"Understanding the warning: \"Guessing: Using type 'xyz', instead of 'abc' , because it has the fewest properties\""},{"location":"api/","text":"Home API Reference \u00b6 Packages \u00b6 Package Description scrubbr","title":"Index"},{"location":"api/#api-reference","text":"","title":"API Reference"},{"location":"api/#packages","text":"Package Description scrubbr","title":"Packages"},{"location":"api/scrubbr.genericserializer/","text":"Home > scrubbr > GenericSerializer GenericSerializer type \u00b6 Serializer called for each node within the data object that is being serialized. Signature: export declare type GenericSerializer = (data: unknown, state: ScrubbrState) => unknown; References: ScrubbrState","title":"Scrubbr.genericserializer"},{"location":"api/scrubbr.genericserializer/#genericserializer-type","text":"Serializer called for each node within the data object that is being serialized. Signature: export declare type GenericSerializer = (data: unknown, state: ScrubbrState) => unknown; References: ScrubbrState","title":"GenericSerializer type"},{"location":"api/scrubbr.jsonschemadefinitions/","text":"Home > scrubbr > JSONSchemaDefinitions JSONSchemaDefinitions type \u00b6 JSON Schema object that can be passed into Scrubbr. This needs to follow the format that ts-json-schema-generator uses: * All types are defined in the root definitions block. * All references ( $ref ) point to definitions within the JSON object. (i.e. no external references) Signature: export declare type JSONSchemaDefinitions = JSONSchema7 | { definitions: { [k: string]: JSONSchema7; }; };","title":"Scrubbr.jsonschemadefinitions"},{"location":"api/scrubbr.jsonschemadefinitions/#jsonschemadefinitions-type","text":"JSON Schema object that can be passed into Scrubbr. This needs to follow the format that ts-json-schema-generator uses: * All types are defined in the root definitions block. * All references ( $ref ) point to definitions within the JSON object. (i.e. no external references) Signature: export declare type JSONSchemaDefinitions = JSONSchema7 | { definitions: { [k: string]: JSONSchema7; }; };","title":"JSONSchemaDefinitions type"},{"location":"api/scrubbr.loglevel/","text":"Home > scrubbr > LogLevel LogLevel enum \u00b6 The scrubbr log level. Setting the log level will enabled logging for that level and below. Signature: export declare enum LogLevel Enumeration Members \u00b6 Member Value Description DEBUG 4 Log additional debug information. Set logNesting to true to also indent the logs with the data nesting. ERROR 1 Log errors INFO 3 Display basic information as well as warnings and errors. NONE 0 Disable logging. WARN 2 Log warnings and errors.","title":"Scrubbr.loglevel"},{"location":"api/scrubbr.loglevel/#loglevel-enum","text":"The scrubbr log level. Setting the log level will enabled logging for that level and below. Signature: export declare enum LogLevel","title":"LogLevel enum"},{"location":"api/scrubbr.loglevel/#enumeration-members","text":"Member Value Description DEBUG 4 Log additional debug information. Set logNesting to true to also indent the logs with the data nesting. ERROR 1 Log errors INFO 3 Display basic information as well as warnings and errors. NONE 0 Disable logging. WARN 2 Log warnings and errors.","title":"Enumeration Members"},{"location":"api/scrubbr/","text":"Home > scrubbr scrubbr package \u00b6 Classes \u00b6 Class Description Scrubbr ScrubbrState Enumerations \u00b6 Enumeration Description LogLevel The scrubbr log level. Setting the log level will enabled logging for that level and below. Functions \u00b6 Function Description useType(typeName, serializedData) Override the type that's being serialized. The return value from this function should be used by custom serializers. Type Aliases \u00b6 Type Alias Description GenericSerializer Serializer called for each node within the data object that is being serialized. JSONSchemaDefinitions JSON Schema object that can be passed into Scrubbr. This needs to follow the format that ts-json-schema-generator uses: * All types are defined in the root definitions block. * All references ( $ref ) point to definitions within the JSON object. (i.e. no external references) ScrubbrOptions Options passed to the Scrubbr constructor TypeSerializer Serializer function called for a specific TypeScript type.","title":"API"},{"location":"api/scrubbr/#scrubbr-package","text":"","title":"scrubbr package"},{"location":"api/scrubbr/#classes","text":"Class Description Scrubbr ScrubbrState","title":"Classes"},{"location":"api/scrubbr/#enumerations","text":"Enumeration Description LogLevel The scrubbr log level. Setting the log level will enabled logging for that level and below.","title":"Enumerations"},{"location":"api/scrubbr/#functions","text":"Function Description useType(typeName, serializedData) Override the type that's being serialized. The return value from this function should be used by custom serializers.","title":"Functions"},{"location":"api/scrubbr/#type-aliases","text":"Type Alias Description GenericSerializer Serializer called for each node within the data object that is being serialized. JSONSchemaDefinitions JSON Schema object that can be passed into Scrubbr. This needs to follow the format that ts-json-schema-generator uses: * All types are defined in the root definitions block. * All references ( $ref ) point to definitions within the JSON object. (i.e. no external references) ScrubbrOptions Options passed to the Scrubbr constructor TypeSerializer Serializer function called for a specific TypeScript type.","title":"Type Aliases"},{"location":"api/scrubbr.scrubbr._constructor_/","text":"Home > scrubbr > Scrubbr > (constructor) Scrubbr.(constructor) \u00b6 Create new scrubbr serializer Signature: constructor(schema: string | JSONSchemaDefinitions, options?: ScrubbrOptions); Parameters \u00b6 Parameter Type Description schema string | JSONSchemaDefinitions The TypeScript schema file or JSON object to use for serialization. options ScrubbrOptions Scrubbr options.","title":"Scrubbr.scrubbr. constructor "},{"location":"api/scrubbr.scrubbr._constructor_/#scrubbrconstructor","text":"Create new scrubbr serializer Signature: constructor(schema: string | JSONSchemaDefinitions, options?: ScrubbrOptions);","title":"Scrubbr.(constructor)"},{"location":"api/scrubbr.scrubbr._constructor_/#parameters","text":"Parameter Type Description schema string | JSONSchemaDefinitions The TypeScript schema file or JSON object to use for serialization. options ScrubbrOptions Scrubbr options.","title":"Parameters"},{"location":"api/scrubbr.scrubbr.addgenericserializer/","text":"Home > scrubbr > Scrubbr > addGenericSerializer Scrubbr.addGenericSerializer() method \u00b6 Add a generic custom serializer function that's called for each node in the object. Signature: addGenericSerializer(serializer: GenericSerializer): void; Parameters \u00b6 Parameter Type Description serializer GenericSerializer The serializer function. Returns: void","title":"Scrubbr.scrubbr.addgenericserializer"},{"location":"api/scrubbr.scrubbr.addgenericserializer/#scrubbraddgenericserializer-method","text":"Add a generic custom serializer function that's called for each node in the object. Signature: addGenericSerializer(serializer: GenericSerializer): void;","title":"Scrubbr.addGenericSerializer() method"},{"location":"api/scrubbr.scrubbr.addgenericserializer/#parameters","text":"Parameter Type Description serializer GenericSerializer The serializer function. Returns: void","title":"Parameters"},{"location":"api/scrubbr.scrubbr.addtypeserializer/","text":"Home > scrubbr > Scrubbr > addTypeSerializer Scrubbr.addTypeSerializer() method \u00b6 Add a function to serialize a schema type Signature: addTypeSerializer(typeName: string | string[], serializer: TypeSerializer): void; Parameters \u00b6 Parameter Type Description typeName string | string[] One or more type names to register the serializer for. serializer TypeSerializer The serializer function. Returns: void","title":"Scrubbr.scrubbr.addtypeserializer"},{"location":"api/scrubbr.scrubbr.addtypeserializer/#scrubbraddtypeserializer-method","text":"Add a function to serialize a schema type Signature: addTypeSerializer(typeName: string | string[], serializer: TypeSerializer): void;","title":"Scrubbr.addTypeSerializer() method"},{"location":"api/scrubbr.scrubbr.addtypeserializer/#parameters","text":"Parameter Type Description typeName string | string[] One or more type names to register the serializer for. serializer TypeSerializer The serializer function. Returns: void","title":"Parameters"},{"location":"api/scrubbr.scrubbr.clone/","text":"Home > scrubbr > Scrubbr > clone Scrubbr.clone() method \u00b6 Create a duplicate version of this scrubbr with all the same serializers, global context, and options. This is useful to create a global scrubbr with serializer that should be used on all data, and all other scrubbrs are created from it for more specific use-cases. Signature: clone(options?: ScrubbrOptions): Scrubbr; Parameters \u00b6 Parameter Type Description options ScrubbrOptions Returns: Scrubbr Example \u00b6 // Global config const scrubbr = new Scrubbr('./schema.ts'); scrubbr.addTypeSerializer('User', userSerializer); // API endpoint function commentListApi() { const commentScrubbr = scrubbr.clone(); commentScrubbr.addTypeSerializer('Comment', commentSerializer); return scrubbr.serialize('CommentList', data); }","title":"Scrubbr.scrubbr.clone"},{"location":"api/scrubbr.scrubbr.clone/#scrubbrclone-method","text":"Create a duplicate version of this scrubbr with all the same serializers, global context, and options. This is useful to create a global scrubbr with serializer that should be used on all data, and all other scrubbrs are created from it for more specific use-cases. Signature: clone(options?: ScrubbrOptions): Scrubbr;","title":"Scrubbr.clone() method"},{"location":"api/scrubbr.scrubbr.clone/#parameters","text":"Parameter Type Description options ScrubbrOptions Returns: Scrubbr","title":"Parameters"},{"location":"api/scrubbr.scrubbr.clone/#example","text":"// Global config const scrubbr = new Scrubbr('./schema.ts'); scrubbr.addTypeSerializer('User', userSerializer); // API endpoint function commentListApi() { const commentScrubbr = scrubbr.clone(); commentScrubbr.addTypeSerializer('Comment', commentSerializer); return scrubbr.serialize('CommentList', data); }","title":"Example"},{"location":"api/scrubbr.scrubbr.getglobalcontext/","text":"Home > scrubbr > Scrubbr > getGlobalContext Scrubbr.getGlobalContext() method \u00b6 Retrieve the global context object. Signature: getGlobalContext(): ContextObject; Returns: ContextObject","title":"Scrubbr.scrubbr.getglobalcontext"},{"location":"api/scrubbr.scrubbr.getglobalcontext/#scrubbrgetglobalcontext-method","text":"Retrieve the global context object. Signature: getGlobalContext(): ContextObject; Returns: ContextObject","title":"Scrubbr.getGlobalContext() method"},{"location":"api/scrubbr.scrubbr.getschema/","text":"Home > scrubbr > Scrubbr > getSchema Scrubbr.getSchema() method \u00b6 Return the entire generated schema for the loaded TypeScript file. Signature: getSchema(): JSONSchema7; Returns: JSONSchema7","title":"Scrubbr.scrubbr.getschema"},{"location":"api/scrubbr.scrubbr.getschema/#scrubbrgetschema-method","text":"Return the entire generated schema for the loaded TypeScript file. Signature: getSchema(): JSONSchema7; Returns: JSONSchema7","title":"Scrubbr.getSchema() method"},{"location":"api/scrubbr.scrubbr.getschemafor/","text":"Home > scrubbr > Scrubbr > getSchemaFor Scrubbr.getSchemaFor() method \u00b6 Get the the generated JSON schema for a TypeScript type. Signature: getSchemaFor(typeName: string): JSONSchema7 | null; Parameters \u00b6 Parameter Type Description typeName string The name of the type to return the schema for. Returns: JSONSchema7 | null The JSON schema for the type, or null if it was not found.","title":"Scrubbr.scrubbr.getschemafor"},{"location":"api/scrubbr.scrubbr.getschemafor/#scrubbrgetschemafor-method","text":"Get the the generated JSON schema for a TypeScript type. Signature: getSchemaFor(typeName: string): JSONSchema7 | null;","title":"Scrubbr.getSchemaFor() method"},{"location":"api/scrubbr.scrubbr.getschemafor/#parameters","text":"Parameter Type Description typeName string The name of the type to return the schema for. Returns: JSONSchema7 | null The JSON schema for the type, or null if it was not found.","title":"Parameters"},{"location":"api/scrubbr.scrubbr.loadschema/","text":"Home > scrubbr > Scrubbr > loadSchema Scrubbr.loadSchema() method \u00b6 Replace the schema with a new one Signature: loadSchema(schema: string | JSONSchemaDefinitions): void; Parameters \u00b6 Parameter Type Description schema string | JSONSchemaDefinitions Returns: void","title":"Scrubbr.scrubbr.loadschema"},{"location":"api/scrubbr.scrubbr.loadschema/#scrubbrloadschema-method","text":"Replace the schema with a new one Signature: loadSchema(schema: string | JSONSchemaDefinitions): void;","title":"Scrubbr.loadSchema() method"},{"location":"api/scrubbr.scrubbr.loadschema/#parameters","text":"Parameter Type Description schema string | JSONSchemaDefinitions Returns: void","title":"Parameters"},{"location":"api/scrubbr.scrubbr/","text":"Home > scrubbr > Scrubbr Scrubbr class \u00b6 Signature: export default class Scrubbr Constructors \u00b6 Constructor Modifiers Description (constructor)(schema, options) Create new scrubbr serializer Properties \u00b6 Property Modifiers Type Description options ScrubbrOptions Methods \u00b6 Method Modifiers Description addGenericSerializer(serializer) Add a generic custom serializer function that's called for each node in the object. addTypeSerializer(typeName, serializer) Add a function to serialize a schema type clone(options) Create a duplicate version of this scrubbr with all the same serializers, global context, and options. This is useful to create a global scrubbr with serializer that should be used on all data, and all other scrubbrs are created from it for more specific use-cases. getGlobalContext() Retrieve the global context object. getSchema() Return the entire generated schema for the loaded TypeScript file. getSchemaFor(typeName) Get the the generated JSON schema for a TypeScript type. loadSchema(schema) Replace the schema with a new one serialize(schemaType, data, context, options) Serialize data based on a TypeScript type. You can influence the return type by using the generic angle brackets: setGlobalContext(context, merge) Set the global context object, that will be automatically merged with the context passed to the serialize function. You can use this for setting things like the logged-in user, at a global level.","title":"Scrubbr.scrubbr"},{"location":"api/scrubbr.scrubbr/#scrubbr-class","text":"Signature: export default class Scrubbr","title":"Scrubbr class"},{"location":"api/scrubbr.scrubbr/#constructors","text":"Constructor Modifiers Description (constructor)(schema, options) Create new scrubbr serializer","title":"Constructors"},{"location":"api/scrubbr.scrubbr/#properties","text":"Property Modifiers Type Description options ScrubbrOptions","title":"Properties"},{"location":"api/scrubbr.scrubbr/#methods","text":"Method Modifiers Description addGenericSerializer(serializer) Add a generic custom serializer function that's called for each node in the object. addTypeSerializer(typeName, serializer) Add a function to serialize a schema type clone(options) Create a duplicate version of this scrubbr with all the same serializers, global context, and options. This is useful to create a global scrubbr with serializer that should be used on all data, and all other scrubbrs are created from it for more specific use-cases. getGlobalContext() Retrieve the global context object. getSchema() Return the entire generated schema for the loaded TypeScript file. getSchemaFor(typeName) Get the the generated JSON schema for a TypeScript type. loadSchema(schema) Replace the schema with a new one serialize(schemaType, data, context, options) Serialize data based on a TypeScript type. You can influence the return type by using the generic angle brackets: setGlobalContext(context, merge) Set the global context object, that will be automatically merged with the context passed to the serialize function. You can use this for setting things like the logged-in user, at a global level.","title":"Methods"},{"location":"api/scrubbr.scrubbr.options/","text":"Home > scrubbr > Scrubbr > options Scrubbr.options property \u00b6 Signature: options: ScrubbrOptions;","title":"Scrubbr.scrubbr.options"},{"location":"api/scrubbr.scrubbr.options/#scrubbroptions-property","text":"Signature: options: ScrubbrOptions;","title":"Scrubbr.options property"},{"location":"api/scrubbr.scrubbr.serialize/","text":"Home > scrubbr > Scrubbr > serialize Scrubbr.serialize() method \u00b6 Serialize data based on a TypeScript type. You can influence the return type by using the generic angle brackets: Signature: serialize<SerializedType = any>(schemaType: string, data: unknown, context?: ContextObject, options?: ScrubbrOptions): SerializedType; Parameters \u00b6 Parameter Type Description schemaType string The name of the typescript type to serialize the data with. data unknown The data to serialize context ContextObject Any data you want sent to the custom serializer functions. options ScrubbrOptions Set options for just this serialization. Returns: SerializedType Example \u00b6 scrubbr.serialize<UserList>('UserList', data);","title":"Scrubbr.scrubbr.serialize"},{"location":"api/scrubbr.scrubbr.serialize/#scrubbrserialize-method","text":"Serialize data based on a TypeScript type. You can influence the return type by using the generic angle brackets: Signature: serialize<SerializedType = any>(schemaType: string, data: unknown, context?: ContextObject, options?: ScrubbrOptions): SerializedType;","title":"Scrubbr.serialize() method"},{"location":"api/scrubbr.scrubbr.serialize/#parameters","text":"Parameter Type Description schemaType string The name of the typescript type to serialize the data with. data unknown The data to serialize context ContextObject Any data you want sent to the custom serializer functions. options ScrubbrOptions Set options for just this serialization. Returns: SerializedType","title":"Parameters"},{"location":"api/scrubbr.scrubbr.serialize/#example","text":"scrubbr.serialize<UserList>('UserList', data);","title":"Example"},{"location":"api/scrubbr.scrubbr.setglobalcontext/","text":"Home > scrubbr > Scrubbr > setGlobalContext Scrubbr.setGlobalContext() method \u00b6 Set the global context object, that will be automatically merged with the context passed to the serialize function. You can use this for setting things like the logged-in user, at a global level. Signature: setGlobalContext(context: ContextObject, merge?: boolean): ContextObject; Parameters \u00b6 Parameter Type Description context ContextObject Any object you want to set as the context. merge boolean Automatically merge this context with the existing global context (defaults false) Otherwise, the global context will be overwritten. Returns: ContextObject","title":"Scrubbr.scrubbr.setglobalcontext"},{"location":"api/scrubbr.scrubbr.setglobalcontext/#scrubbrsetglobalcontext-method","text":"Set the global context object, that will be automatically merged with the context passed to the serialize function. You can use this for setting things like the logged-in user, at a global level. Signature: setGlobalContext(context: ContextObject, merge?: boolean): ContextObject;","title":"Scrubbr.setGlobalContext() method"},{"location":"api/scrubbr.scrubbr.setglobalcontext/#parameters","text":"Parameter Type Description context ContextObject Any object you want to set as the context. merge boolean Automatically merge this context with the existing global context (defaults false) Otherwise, the global context will be overwritten. Returns: ContextObject","title":"Parameters"},{"location":"api/scrubbr.scrubbroptions/","text":"Home > scrubbr > ScrubbrOptions ScrubbrOptions type \u00b6 Options passed to the Scrubbr constructor Signature: export declare type ScrubbrOptions = { logLevel?: LogLevel; logNesting?: boolean | string; logPrefix?: string; throwOnError?: boolean; }; References: LogLevel","title":"Scrubbr.scrubbroptions"},{"location":"api/scrubbr.scrubbroptions/#scrubbroptions-type","text":"Options passed to the Scrubbr constructor Signature: export declare type ScrubbrOptions = { logLevel?: LogLevel; logNesting?: boolean | string; logPrefix?: string; throwOnError?: boolean; }; References: LogLevel","title":"ScrubbrOptions type"},{"location":"api/scrubbr.scrubbrstate._constructor_/","text":"Home > scrubbr > ScrubbrState > (constructor) ScrubbrState.(constructor) \u00b6 Constructs a new instance of the ScrubbrState class Signature: constructor(data: any, schema: JSONSchema7, options: ScrubbrOptions, context: any, path?: string, nesting?: number); Parameters \u00b6 Parameter Type Description data any schema JSONSchema7 options ScrubbrOptions context any path string nesting number","title":"Scrubbr.scrubbrstate. constructor "},{"location":"api/scrubbr.scrubbrstate._constructor_/#scrubbrstateconstructor","text":"Constructs a new instance of the ScrubbrState class Signature: constructor(data: any, schema: JSONSchema7, options: ScrubbrOptions, context: any, path?: string, nesting?: number);","title":"ScrubbrState.(constructor)"},{"location":"api/scrubbr.scrubbrstate._constructor_/#parameters","text":"Parameter Type Description data any schema JSONSchema7 options ScrubbrOptions context any path string nesting number","title":"Parameters"},{"location":"api/scrubbr.scrubbrstate.context/","text":"Home > scrubbr > ScrubbrState > context ScrubbrState.context property \u00b6 The context object passed to the serialize function. Signature: context: any;","title":"Scrubbr.scrubbrstate.context"},{"location":"api/scrubbr.scrubbrstate.context/#scrubbrstatecontext-property","text":"The context object passed to the serialize function. Signature: context: any;","title":"ScrubbrState.context property"},{"location":"api/scrubbr.scrubbrstate.createliststate/","text":"Home > scrubbr > ScrubbrState > createListState ScrubbrState.createListState() method \u00b6 Create a child array index state, derived off of this state. Signature: createListState(data: any, index: number, path: string, schema: JSONSchema7): ScrubbrState; Parameters \u00b6 Parameter Type Description data any index number path string schema JSONSchema7 Returns: ScrubbrState","title":"Scrubbr.scrubbrstate.createliststate"},{"location":"api/scrubbr.scrubbrstate.createliststate/#scrubbrstatecreateliststate-method","text":"Create a child array index state, derived off of this state. Signature: createListState(data: any, index: number, path: string, schema: JSONSchema7): ScrubbrState;","title":"ScrubbrState.createListState() method"},{"location":"api/scrubbr.scrubbrstate.createliststate/#parameters","text":"Parameter Type Description data any index number path string schema JSONSchema7 Returns: ScrubbrState","title":"Parameters"},{"location":"api/scrubbr.scrubbrstate.createnodestate/","text":"Home > scrubbr > ScrubbrState > createNodeState ScrubbrState.createNodeState() method \u00b6 Create a child property node state, derived off of this state. Signature: createNodeState(data: any, name: string, path: string, schema: JSONSchema7): ScrubbrState; Parameters \u00b6 Parameter Type Description data any name string path string schema JSONSchema7 Returns: ScrubbrState","title":"Scrubbr.scrubbrstate.createnodestate"},{"location":"api/scrubbr.scrubbrstate.createnodestate/#scrubbrstatecreatenodestate-method","text":"Create a child property node state, derived off of this state. Signature: createNodeState(data: any, name: string, path: string, schema: JSONSchema7): ScrubbrState;","title":"ScrubbrState.createNodeState() method"},{"location":"api/scrubbr.scrubbrstate.createnodestate/#parameters","text":"Parameter Type Description data any name string path string schema JSONSchema7 Returns: ScrubbrState","title":"Parameters"},{"location":"api/scrubbr.scrubbrstate.index/","text":"Home > scrubbr > ScrubbrState > index ScrubbrState.index property \u00b6 If we're currently serializing an array, this is the array index Signature: index: number | null;","title":"Scrubbr.scrubbrstate.index"},{"location":"api/scrubbr.scrubbrstate.index/#scrubbrstateindex-property","text":"If we're currently serializing an array, this is the array index Signature: index: number | null;","title":"ScrubbrState.index property"},{"location":"api/scrubbr.scrubbrstate.logger/","text":"Home > scrubbr > ScrubbrState > logger ScrubbrState.logger property \u00b6 Signature: logger: Logger;","title":"Scrubbr.scrubbrstate.logger"},{"location":"api/scrubbr.scrubbrstate.logger/#scrubbrstatelogger-property","text":"Signature: logger: Logger;","title":"ScrubbrState.logger property"},{"location":"api/scrubbr.scrubbrstate/","text":"Home > scrubbr > ScrubbrState ScrubbrState class \u00b6 Signature: export declare class ScrubbrState Constructors \u00b6 Constructor Modifiers Description (constructor)(data, schema, options, context, path, nesting) Constructs a new instance of the ScrubbrState class Properties \u00b6 Property Modifiers Type Description context any The context object passed to the serialize function. index number | null If we're currently serializing an array, this is the array index logger Logger name string The property name of the data being serialized. nesting number The nesting level at this node of the data being serialized. options ScrubbrOptions originalData any Unserialized data at this node. parent ScrubbrState | null The state of the parent node path string The current object path rootSchemaType string The schema type we're serializing the document with. schemaDef JSONSchema7 JSON Schema object of the current data node type. schemaType string | null The schema type of the current data node. seenTypes string[] The schema types that have been used to serialize this node. Methods \u00b6 Method Modifiers Description createListState(data, index, path, schema) Create a child array index state, derived off of this state. createNodeState(data, name, path, schema) Create a child property node state, derived off of this state.","title":"Scrubbr.scrubbrstate"},{"location":"api/scrubbr.scrubbrstate/#scrubbrstate-class","text":"Signature: export declare class ScrubbrState","title":"ScrubbrState class"},{"location":"api/scrubbr.scrubbrstate/#constructors","text":"Constructor Modifiers Description (constructor)(data, schema, options, context, path, nesting) Constructs a new instance of the ScrubbrState class","title":"Constructors"},{"location":"api/scrubbr.scrubbrstate/#properties","text":"Property Modifiers Type Description context any The context object passed to the serialize function. index number | null If we're currently serializing an array, this is the array index logger Logger name string The property name of the data being serialized. nesting number The nesting level at this node of the data being serialized. options ScrubbrOptions originalData any Unserialized data at this node. parent ScrubbrState | null The state of the parent node path string The current object path rootSchemaType string The schema type we're serializing the document with. schemaDef JSONSchema7 JSON Schema object of the current data node type. schemaType string | null The schema type of the current data node. seenTypes string[] The schema types that have been used to serialize this node.","title":"Properties"},{"location":"api/scrubbr.scrubbrstate/#methods","text":"Method Modifiers Description createListState(data, index, path, schema) Create a child array index state, derived off of this state. createNodeState(data, name, path, schema) Create a child property node state, derived off of this state.","title":"Methods"},{"location":"api/scrubbr.scrubbrstate.name/","text":"Home > scrubbr > ScrubbrState > name ScrubbrState.name property \u00b6 The property name of the data being serialized. Signature: name: string;","title":"Scrubbr.scrubbrstate.name"},{"location":"api/scrubbr.scrubbrstate.name/#scrubbrstatename-property","text":"The property name of the data being serialized. Signature: name: string;","title":"ScrubbrState.name property"},{"location":"api/scrubbr.scrubbrstate.nesting/","text":"Home > scrubbr > ScrubbrState > nesting ScrubbrState.nesting property \u00b6 The nesting level at this node of the data being serialized. Signature: nesting: number;","title":"Scrubbr.scrubbrstate.nesting"},{"location":"api/scrubbr.scrubbrstate.nesting/#scrubbrstatenesting-property","text":"The nesting level at this node of the data being serialized. Signature: nesting: number;","title":"ScrubbrState.nesting property"},{"location":"api/scrubbr.scrubbrstate.options/","text":"Home > scrubbr > ScrubbrState > options ScrubbrState.options property \u00b6 Signature: options: ScrubbrOptions;","title":"Scrubbr.scrubbrstate.options"},{"location":"api/scrubbr.scrubbrstate.options/#scrubbrstateoptions-property","text":"Signature: options: ScrubbrOptions;","title":"ScrubbrState.options property"},{"location":"api/scrubbr.scrubbrstate.originaldata/","text":"Home > scrubbr > ScrubbrState > originalData ScrubbrState.originalData property \u00b6 Unserialized data at this node. Signature: originalData: any;","title":"Scrubbr.scrubbrstate.originaldata"},{"location":"api/scrubbr.scrubbrstate.originaldata/#scrubbrstateoriginaldata-property","text":"Unserialized data at this node. Signature: originalData: any;","title":"ScrubbrState.originalData property"},{"location":"api/scrubbr.scrubbrstate.parent/","text":"Home > scrubbr > ScrubbrState > parent ScrubbrState.parent property \u00b6 The state of the parent node Signature: parent: ScrubbrState | null;","title":"Scrubbr.scrubbrstate.parent"},{"location":"api/scrubbr.scrubbrstate.parent/#scrubbrstateparent-property","text":"The state of the parent node Signature: parent: ScrubbrState | null;","title":"ScrubbrState.parent property"},{"location":"api/scrubbr.scrubbrstate.path/","text":"Home > scrubbr > ScrubbrState > path ScrubbrState.path property \u00b6 The current object path Signature: path: string;","title":"Scrubbr.scrubbrstate.path"},{"location":"api/scrubbr.scrubbrstate.path/#scrubbrstatepath-property","text":"The current object path Signature: path: string;","title":"ScrubbrState.path property"},{"location":"api/scrubbr.scrubbrstate.rootschematype/","text":"Home > scrubbr > ScrubbrState > rootSchemaType ScrubbrState.rootSchemaType property \u00b6 The schema type we're serializing the document with. Signature: rootSchemaType: string;","title":"Scrubbr.scrubbrstate.rootschematype"},{"location":"api/scrubbr.scrubbrstate.rootschematype/#scrubbrstaterootschematype-property","text":"The schema type we're serializing the document with. Signature: rootSchemaType: string;","title":"ScrubbrState.rootSchemaType property"},{"location":"api/scrubbr.scrubbrstate.schemadef/","text":"Home > scrubbr > ScrubbrState > schemaDef ScrubbrState.schemaDef property \u00b6 JSON Schema object of the current data node type. Signature: schemaDef: JSONSchema7;","title":"Scrubbr.scrubbrstate.schemadef"},{"location":"api/scrubbr.scrubbrstate.schemadef/#scrubbrstateschemadef-property","text":"JSON Schema object of the current data node type. Signature: schemaDef: JSONSchema7;","title":"ScrubbrState.schemaDef property"},{"location":"api/scrubbr.scrubbrstate.schematype/","text":"Home > scrubbr > ScrubbrState > schemaType ScrubbrState.schemaType property \u00b6 The schema type of the current data node. Signature: schemaType: string | null;","title":"Scrubbr.scrubbrstate.schematype"},{"location":"api/scrubbr.scrubbrstate.schematype/#scrubbrstateschematype-property","text":"The schema type of the current data node. Signature: schemaType: string | null;","title":"ScrubbrState.schemaType property"},{"location":"api/scrubbr.scrubbrstate.seentypes/","text":"Home > scrubbr > ScrubbrState > seenTypes ScrubbrState.seenTypes property \u00b6 The schema types that have been used to serialize this node. Signature: seenTypes: string[];","title":"Scrubbr.scrubbrstate.seentypes"},{"location":"api/scrubbr.scrubbrstate.seentypes/#scrubbrstateseentypes-property","text":"The schema types that have been used to serialize this node. Signature: seenTypes: string[];","title":"ScrubbrState.seenTypes property"},{"location":"api/scrubbr.typeserializer/","text":"Home > scrubbr > TypeSerializer TypeSerializer type \u00b6 Serializer function called for a specific TypeScript type. Signature: export declare type TypeSerializer = (data: unknown, state: ScrubbrState) => unknown; References: ScrubbrState","title":"Scrubbr.typeserializer"},{"location":"api/scrubbr.typeserializer/#typeserializer-type","text":"Serializer function called for a specific TypeScript type. Signature: export declare type TypeSerializer = (data: unknown, state: ScrubbrState) => unknown; References: ScrubbrState","title":"TypeSerializer type"},{"location":"api/scrubbr.usetype/","text":"Home > scrubbr > useType useType() function \u00b6 Override the type that's being serialized. The return value from this function should be used by custom serializers. Signature: export declare function useType(typeName: string, serializedData?: unknown): UseType; Parameters \u00b6 Parameter Type Description typeName string The type that this node should be serialized with. serializedData unknown Serialized/transformed data for this node. Returns: UseType Example \u00b6 // Convert all User types to PublicUser scrubbr.typeSerializer('User', (data, state) =\\> useType('PublicUser'));","title":"Scrubbr.usetype"},{"location":"api/scrubbr.usetype/#usetype-function","text":"Override the type that's being serialized. The return value from this function should be used by custom serializers. Signature: export declare function useType(typeName: string, serializedData?: unknown): UseType;","title":"useType() function"},{"location":"api/scrubbr.usetype/#parameters","text":"Parameter Type Description typeName string The type that this node should be serialized with. serializedData unknown Serialized/transformed data for this node. Returns: UseType","title":"Parameters"},{"location":"api/scrubbr.usetype/#example","text":"// Convert all User types to PublicUser scrubbr.typeSerializer('User', (data, state) =\\> useType('PublicUser'));","title":"Example"}]}