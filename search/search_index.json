{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Scrubbr \u00b6 Serializing data in node shouldn't be hard. You shouldn't have to worry about accidentally leaking private information through your APIs. If you're using TypeScript, you already have everythign you need to effortlessly serialize and transform your data. Scrubbr transforms your TypeScript into a JSON schema and uses that to format your data. Install \u00b6 npm i -S scrubbr Quick Start \u00b6 The simplest example is to filter out sensitive data. In this example we want to filter the email and password out of this sample data: { users: [ { name: 'John Doe', image: 'http://i.pravatar.cc/300', email: 'donotspam@me.com', password: 'xxxsecretxxx', }, ], }; 1. Define your TypeScript schema \u00b6 First define a TypeScript schema file that only contains the properties you want in our output. // schema.ts type UserList = { users: User[]; }; type User = { name: string; image: string; }; 2. Serialize with Scrubbr \u00b6 Now initialize Scrubbr with a path to the schema file and serialize the data. import Scrubbr from 'scrubbr'; // PERFORMANCE NOTE: this is a synchronous call! // Load early and cache to a shared variable. const scrubbr = new Scrubbr('./schema.ts'); async function api() { const data = getUsers(); // Serialize the data based on the UserList type defined in schema.ts return await scrubbr.serialize('UserList', data); } 3. Ouput \u00b6 { \"users\": [ { \"name\": \"John Doe\", \"image\": \"http://i.pravatar.cc/300\" } ] } That's it \u00b6 Follow along for more advanced features. Learn about Custom Serializers next.","title":"Scrubbr"},{"location":"#scrubbr","text":"Serializing data in node shouldn't be hard. You shouldn't have to worry about accidentally leaking private information through your APIs. If you're using TypeScript, you already have everythign you need to effortlessly serialize and transform your data. Scrubbr transforms your TypeScript into a JSON schema and uses that to format your data.","title":"Scrubbr"},{"location":"#install","text":"npm i -S scrubbr","title":"Install"},{"location":"#quick-start","text":"The simplest example is to filter out sensitive data. In this example we want to filter the email and password out of this sample data: { users: [ { name: 'John Doe', image: 'http://i.pravatar.cc/300', email: 'donotspam@me.com', password: 'xxxsecretxxx', }, ], };","title":"Quick Start"},{"location":"#1-define-your-typescript-schema","text":"First define a TypeScript schema file that only contains the properties you want in our output. // schema.ts type UserList = { users: User[]; }; type User = { name: string; image: string; };","title":"1. Define your TypeScript schema"},{"location":"#2-serialize-with-scrubbr","text":"Now initialize Scrubbr with a path to the schema file and serialize the data. import Scrubbr from 'scrubbr'; // PERFORMANCE NOTE: this is a synchronous call! // Load early and cache to a shared variable. const scrubbr = new Scrubbr('./schema.ts'); async function api() { const data = getUsers(); // Serialize the data based on the UserList type defined in schema.ts return await scrubbr.serialize('UserList', data); }","title":"2. Serialize with Scrubbr"},{"location":"#3-ouput","text":"{ \"users\": [ { \"name\": \"John Doe\", \"image\": \"http://i.pravatar.cc/300\" } ] }","title":"3. Ouput"},{"location":"#thats-it","text":"Follow along for more advanced features. Learn about Custom Serializers next.","title":"That's it"},{"location":"serializers/","text":"Custom Serializers \u00b6 Custom serializers give you the power to transform data and influence Scrubbr. Type Serializers \u00b6 The most common serializer is the Type Serializer. This function is called whenever Scrubbr encounters a specific TypeScript type anywhere in the data. scrubbr.addTypeSerializer('User', (data, state) => { // Do custom things here for User typed data return data; }); Context \u00b6 You can pass a custom object to the serialize function, and it will be passed to your serializers inside the state param. For example, it could be the ID of the logged-in user: const context = { userId: 5 } scrubbr.addTypeSerializer('User', serializeUser); const serialized = await scrubbr.serialize('MemberList', data, context); // Only return the logged-in user function serializeUser(data, state) { const { context } = state; if (data.id !== context.userId) { return null; } return data; } Global Context \u00b6 You can also set the context globally and it will be merged with the context passed into the serialize function. For example: function userLoggedIn(user) { scrubbr.setGlobalContext({ loggedInUserId: user.id }); } function api() { const context = { timezone: 'America/Los_Angeles', }; const serialized = await scrubbr.serialize('MemberList', data, context); } In this example, the context passed to serializers will potentially include both timezone and loggedInUserId , if the userLoggedIn function were called. Change Types \u00b6 Your serializer can tell Scrubbr to use a different type for serialization with the useType function. For example, maybe we want to use the limited PublicUser type for all User objects that are not the logged-in user: type User = { id: number; name: string; email: string; password: string; } type PublicUser = { id: number; name: string; } import Scrubbr, { useType } from '../src/'; const context = { userId: 5 } scrubbr.addTypeSerializer('User', serializeUser); const serialized = await scrubbr.serialize('MemberList', data, context); // Convert User to PublicUser for everyone but the logged-in user function serializeUser(data, state) { const { context } = state; if (data.id !== context.userId) { return useType('PublicUser'); } return data; } Generic Serializers \u00b6 Generic serializers are called for every node in the object being serialized. Be aware that this can slow down the overall serialization process. scrubbr.addGenericSerializer((data, state) => { // Transform the data here return data; }); Inside the serializer you'll often uses the following state properties to determine where you are: state.path - The object path to where you are (i.e. blog.posts[1].author.name ) state.name - The name of the property that is being serialized. state.index - If the node being serialized is an item in an array, this is the index in that array. Note In most cases Type Serializers provide a cleaner and more elegant way to serialize your data than Generic Serializers. Let's say we want to convert every startTime date value to the local timezone. type Event = { name: string; startTime: Date; } type Meeting = { name: string; startTime: string; recurring: string; } type AppointmentList = { events: Event[]; meeting: Meeting[]; } import moment from 'moment-timezone'; import Scrubbr, {ScrubbrState} from 'scrubbr'; const scrubbr = new Scrubbr('./schema.ts'); function serializeStartTime(data: any, state: ScrubbrState) { const { name } = state; const { timezone } = state.context; if (name == 'startTime') { return moment(data).tz(timezone).format(); } return data; } function api() { const data = getData(); const context = { timezone: 'America/Los_Angeles', }; scrubbr.addGenericSerializer(serializeStartTime); const serialized = await scrubbr.serialize('AppointmentList', data, context); } function getData() { return { events: [ { name: 'Pool party', startTime: '2021-06-26T19:00:00.000Z', } ], meeting: [ { name: 'Daily standup', startTime: '2021-06-25T17:00:00.000Z', recurring: 'daily', } ] } } Alternate Example \u00b6 But let's see a more elegant way to handle the previous example. Instead of using the crude generic serializer, you can apply a consistent type to startTime and use a type serializer. type StartTime = Date; type Event = { name: string; startTime: StartTime; } type Meeting = { name: string; startTime: StartTime; } type AppointmentList = { events: Event[]; meeting: Meeting[]; recurring: string; } import moment from 'moment-timezone'; import Scrubbr, {ScrubbrState} from 'scrubbr'; const scrubbr = new Scrubbr('./schema.ts'); function serializeStartTime(data: any, state: ScrubbrState) { const { name } = state; const { timezone } = state.context; return moment(data).tz(timezone).format(); } function api() { const data = getData(); const context = { timezone: 'America/Los_Angeles', }; scrubbr.addTypeSerializer('StartTime', serializeStartTime); const serialized = await scrubbr.serialize('AppointmentList', data, context); } function getData() { return { events: [ { name: 'Pool party', startTime: '2021-06-26T19:00:00.000Z', } ], meeting: [ { name: 'Daily standup', startTime: '2021-06-25T17:00:00.000Z', recurring: 'daily', } ] } }","title":"Custom Serializers"},{"location":"serializers/#custom-serializers","text":"Custom serializers give you the power to transform data and influence Scrubbr.","title":"Custom Serializers"},{"location":"serializers/#type-serializers","text":"The most common serializer is the Type Serializer. This function is called whenever Scrubbr encounters a specific TypeScript type anywhere in the data. scrubbr.addTypeSerializer('User', (data, state) => { // Do custom things here for User typed data return data; });","title":"Type Serializers"},{"location":"serializers/#context","text":"You can pass a custom object to the serialize function, and it will be passed to your serializers inside the state param. For example, it could be the ID of the logged-in user: const context = { userId: 5 } scrubbr.addTypeSerializer('User', serializeUser); const serialized = await scrubbr.serialize('MemberList', data, context); // Only return the logged-in user function serializeUser(data, state) { const { context } = state; if (data.id !== context.userId) { return null; } return data; }","title":"Context"},{"location":"serializers/#global-context","text":"You can also set the context globally and it will be merged with the context passed into the serialize function. For example: function userLoggedIn(user) { scrubbr.setGlobalContext({ loggedInUserId: user.id }); } function api() { const context = { timezone: 'America/Los_Angeles', }; const serialized = await scrubbr.serialize('MemberList', data, context); } In this example, the context passed to serializers will potentially include both timezone and loggedInUserId , if the userLoggedIn function were called.","title":"Global Context"},{"location":"serializers/#change-types","text":"Your serializer can tell Scrubbr to use a different type for serialization with the useType function. For example, maybe we want to use the limited PublicUser type for all User objects that are not the logged-in user: type User = { id: number; name: string; email: string; password: string; } type PublicUser = { id: number; name: string; } import Scrubbr, { useType } from '../src/'; const context = { userId: 5 } scrubbr.addTypeSerializer('User', serializeUser); const serialized = await scrubbr.serialize('MemberList', data, context); // Convert User to PublicUser for everyone but the logged-in user function serializeUser(data, state) { const { context } = state; if (data.id !== context.userId) { return useType('PublicUser'); } return data; }","title":"Change Types"},{"location":"serializers/#generic-serializers","text":"Generic serializers are called for every node in the object being serialized. Be aware that this can slow down the overall serialization process. scrubbr.addGenericSerializer((data, state) => { // Transform the data here return data; }); Inside the serializer you'll often uses the following state properties to determine where you are: state.path - The object path to where you are (i.e. blog.posts[1].author.name ) state.name - The name of the property that is being serialized. state.index - If the node being serialized is an item in an array, this is the index in that array. Note In most cases Type Serializers provide a cleaner and more elegant way to serialize your data than Generic Serializers. Let's say we want to convert every startTime date value to the local timezone. type Event = { name: string; startTime: Date; } type Meeting = { name: string; startTime: string; recurring: string; } type AppointmentList = { events: Event[]; meeting: Meeting[]; } import moment from 'moment-timezone'; import Scrubbr, {ScrubbrState} from 'scrubbr'; const scrubbr = new Scrubbr('./schema.ts'); function serializeStartTime(data: any, state: ScrubbrState) { const { name } = state; const { timezone } = state.context; if (name == 'startTime') { return moment(data).tz(timezone).format(); } return data; } function api() { const data = getData(); const context = { timezone: 'America/Los_Angeles', }; scrubbr.addGenericSerializer(serializeStartTime); const serialized = await scrubbr.serialize('AppointmentList', data, context); } function getData() { return { events: [ { name: 'Pool party', startTime: '2021-06-26T19:00:00.000Z', } ], meeting: [ { name: 'Daily standup', startTime: '2021-06-25T17:00:00.000Z', recurring: 'daily', } ] } }","title":"Generic Serializers"},{"location":"serializers/#alternate-example","text":"But let's see a more elegant way to handle the previous example. Instead of using the crude generic serializer, you can apply a consistent type to startTime and use a type serializer. type StartTime = Date; type Event = { name: string; startTime: StartTime; } type Meeting = { name: string; startTime: StartTime; } type AppointmentList = { events: Event[]; meeting: Meeting[]; recurring: string; } import moment from 'moment-timezone'; import Scrubbr, {ScrubbrState} from 'scrubbr'; const scrubbr = new Scrubbr('./schema.ts'); function serializeStartTime(data: any, state: ScrubbrState) { const { name } = state; const { timezone } = state.context; return moment(data).tz(timezone).format(); } function api() { const data = getData(); const context = { timezone: 'America/Los_Angeles', }; scrubbr.addTypeSerializer('StartTime', serializeStartTime); const serialized = await scrubbr.serialize('AppointmentList', data, context); } function getData() { return { events: [ { name: 'Pool party', startTime: '2021-06-26T19:00:00.000Z', } ], meeting: [ { name: 'Daily standup', startTime: '2021-06-25T17:00:00.000Z', recurring: 'daily', } ] } }","title":"Alternate Example"},{"location":"tips/","text":"Tips & Tricks \u00b6 TypeScript Typing \u00b6 If you want to cast the serialized data to the type you serialized it to, just use the angle brackets: import { UserList } from 'schema'; const results = scrubbr.serialize<UserList>('UserList', data); Improving startup performance \u00b6 Converting the TypeScript to JSON can take a few moments. If you want to optimize startup time, you can save the schema to disk as part of your build step and then pass it directly to Scrubbr. Internally, Scrubbr uses the ts-json-schema-generator library to convert TypeScript to JSON schema. Warning You cannot load just any JSON schema into scrubbr, it needs to follow the output conventions of ts-json-schema-generator : All types are defined in the root definitions object. All references ( $ref ) point to definitions within the object. (i.e. no external references) Build Step \u00b6 This will build your schema file ( schema.ts ) and output it to dist/schema.json . npx ts-json-schema-generator -f ./tsconfig.json -e all -p ./schema.ts -o ./dist/schema.json Runtime code \u00b6 import Scrubbr, { JSONSchemaDefinitions } from 'scrubbr'; // Set `resolveJsonModule: true` in your tsconfig, otherwise use require() import * as schema from './schema.json'; const scrubbr = new Scrubbr(schema as JSONSchemaDefinitions); Schema Validation \u00b6 For the sake of performance and simplicity, scrubber does not perform a schema validation. However, you can easily use ajv to validate the serialized object. import Ajv from 'ajv'; import Scrubbr from 'scrubbr'; const scrubbr = new Scrubbr('./schema.ts'); async function main() { // Serialize const output = await scrubbr.serialize('UserList', data); const jsonSchema = scrubbr.getSchemaFor('UserList'); // Validate const ajv = new Ajv(); const schemaValidator = ajv.compile(jsonSchema); const isValid = schemaValidator(output); if (!isValid) { console.error(schemaValidator.errors); } }","title":"Tips & Tricks"},{"location":"tips/#tips-tricks","text":"","title":"Tips &amp; Tricks"},{"location":"tips/#typescript-typing","text":"If you want to cast the serialized data to the type you serialized it to, just use the angle brackets: import { UserList } from 'schema'; const results = scrubbr.serialize<UserList>('UserList', data);","title":"TypeScript Typing"},{"location":"tips/#improving-startup-performance","text":"Converting the TypeScript to JSON can take a few moments. If you want to optimize startup time, you can save the schema to disk as part of your build step and then pass it directly to Scrubbr. Internally, Scrubbr uses the ts-json-schema-generator library to convert TypeScript to JSON schema. Warning You cannot load just any JSON schema into scrubbr, it needs to follow the output conventions of ts-json-schema-generator : All types are defined in the root definitions object. All references ( $ref ) point to definitions within the object. (i.e. no external references)","title":"Improving startup performance"},{"location":"tips/#build-step","text":"This will build your schema file ( schema.ts ) and output it to dist/schema.json . npx ts-json-schema-generator -f ./tsconfig.json -e all -p ./schema.ts -o ./dist/schema.json","title":"Build Step"},{"location":"tips/#runtime-code","text":"import Scrubbr, { JSONSchemaDefinitions } from 'scrubbr'; // Set `resolveJsonModule: true` in your tsconfig, otherwise use require() import * as schema from './schema.json'; const scrubbr = new Scrubbr(schema as JSONSchemaDefinitions);","title":"Runtime code"},{"location":"tips/#schema-validation","text":"For the sake of performance and simplicity, scrubber does not perform a schema validation. However, you can easily use ajv to validate the serialized object. import Ajv from 'ajv'; import Scrubbr from 'scrubbr'; const scrubbr = new Scrubbr('./schema.ts'); async function main() { // Serialize const output = await scrubbr.serialize('UserList', data); const jsonSchema = scrubbr.getSchemaFor('UserList'); // Validate const ajv = new Ajv(); const schemaValidator = ajv.compile(jsonSchema); const isValid = schemaValidator(output); if (!isValid) { console.error(schemaValidator.errors); } }","title":"Schema Validation"},{"location":"troubleshooting/","text":"Troubleshooting \u00b6 Look at the generated schema \u00b6 If scrubbr is not returning the data you're expecting, the first place to look is at the internal schema definitions: console.log(scrubbr.getSchema()); Note This is the JSON schema that was created from your TypeScript file. Next look at the schema definition for the TypeScript type you're trying to serialize to. console.log(scrubbr.getSchemaFor('UserList')); Verify that this returns a JSON schema object and that it contains the properties you want serialized. Debug output \u00b6 To enable debug logging: import Scrubbr, { LogLevel } from 'scrubbr'; const scrubbr = new Scrubbr('./schema.ts', { logLevel: LogLevel.DEBUG }); Scrubbr can also nest the logs to make it easier to read: const scrubbr = new Scrubbr('./schema.ts', { logLevel: LogLevel.DEBUG, logNesting: true, // or enter a string if you want to use a custom indention });","title":"Troubleshooting"},{"location":"troubleshooting/#troubleshooting","text":"","title":"Troubleshooting"},{"location":"troubleshooting/#look-at-the-generated-schema","text":"If scrubbr is not returning the data you're expecting, the first place to look is at the internal schema definitions: console.log(scrubbr.getSchema()); Note This is the JSON schema that was created from your TypeScript file. Next look at the schema definition for the TypeScript type you're trying to serialize to. console.log(scrubbr.getSchemaFor('UserList')); Verify that this returns a JSON schema object and that it contains the properties you want serialized.","title":"Look at the generated schema"},{"location":"troubleshooting/#debug-output","text":"To enable debug logging: import Scrubbr, { LogLevel } from 'scrubbr'; const scrubbr = new Scrubbr('./schema.ts', { logLevel: LogLevel.DEBUG }); Scrubbr can also nest the logs to make it easier to read: const scrubbr = new Scrubbr('./schema.ts', { logLevel: LogLevel.DEBUG, logNesting: true, // or enter a string if you want to use a custom indention });","title":"Debug output"}]}